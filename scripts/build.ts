import { readdir, readFile, writeFile, ensureDir, emptyDir } from 'fs-extra'
import { minify } from 'html-minifier'
import { resolve, parse } from 'path'
import { build } from 'vite'
import { promisify } from 'util'
import { gzip as _gzip, constants as ZLIB } from 'zlib'
import { toHexString, buildWLEDServerRoute } from './utils'
import { lookup } from 'mime-types'
const toAbsolute = (...p:string[]) => resolve(__dirname, ...p)
const gzip = promisify(_gzip)

async function init() {
	let total_size = 0
	let total_compressed_size = 0
	let wled_ui_imports = '// Includes for static UI header files, do not edit'
	let viewled_server_routes:string[] = []

	await emptyDir(toAbsolute('../dist')) // Make sure we clear out old build files

	// First, use Vite to build the static client-side files which will be gzipped and served by WLED
	await build({
		root: toAbsolute('../'),
		build: {
			outDir: toAbsolute('../dist/static'),
			rollupOptions: {
				plugins: []
			},
			ssrManifest: true
		}
	})

	// Next, use Vite again to build a node-renderable version of the project
	await build({
		root: toAbsolute('../'),
		build: {
			outDir: toAbsolute('../dist/node'),
			rollupOptions: {
				input: ['src/entry-node.ts']
			},
			ssr: true
		}
	})

	// Make sure we make a `wled00` directory to store the final header files in
	await ensureDir(toAbsolute('../dist/wled00'))
	await ensureDir(toAbsolute('../dist/wled00/ui'))
	await ensureDir(toAbsolute('../dist/wled00/ui/assets'))

	// When the project is built, import the generated manifest and the node renderer from the first two steps
	/// @ts-ignore
	const manifest = await import('../dist/static/ssr-manifest.json')
	/// @ts-ignore
	const { render } = await import('../dist/node/entry-node.js')

	//
	// Handle App Routes

	const template = await readFile(toAbsolute('../dist/static/index.html'), 'utf-8') // Load the statically generated `index.html` from the first step to be used as a base template
	const routes = (await readdir(toAbsolute('../src/pages'))).map(file => { // Read the `src/pages` directory and map each `*.vue` file to a server route (eg `index.vue` -> `/` or `colors.vue` -> `/colors`)
		const name = file.replace(/\.vue$/, '').toLowerCase()
		return name === 'index' ? `/` : `/${name}`
	})

	for (const route of routes) { // Loop through each route
		const file_name = `${ route === '/' ? '/index' : route }.html` // Convert the route to its equivalent static HTML file
		const file_path = `../dist/static${ file_name }` // The relative path where the static HTML file will be written
		const { ext, name } = parse(file_path) // Split the extension and file name

		const [appHtml, preloadLinks] = await render(route, manifest) // Use the node renderer to generate 
		let html = template.replace(`<!--preload-links-->`, preloadLinks).replace(`<!--ssr-outlet-->`, appHtml) // Inject the rendered html and preload links into the template file
		html = minify(html, { removeAttributeQuotes: true, collapseWhitespace: true }) // Minify the static HTML for extra space saving

		await writeFile(toAbsolute(file_path), html) // Write static HTML file for this route

		const gzip_buffer = await gzip(html, { level: ZLIB.Z_BEST_COMPRESSION }) // Compress the HTML file

		// Build a static header file for this route
		const header_source = `/*
 * Binary array for VieWLED UI route.
 * gzip is used for smaller size and improved speeds.
 */

// Autogenerated from ${ file_name }, do not edit
const uint16_t PAGE_${name}_L = ${ gzip_buffer.length };
const uint8_t PAGE_${name}[] PROGMEM = {
${ toHexString(gzip_buffer) }
};`

		let header_file = `${ ext.replace('.', '') }_${ name }.h` // eg `/` -> `html_index.h` or `/colors` -> `html_colors.h`
		await writeFile(toAbsolute(`../dist/wled00/ui/${ header_file }`), header_source) // Write the header file

		// Add a new line to the WLED router code for this route
		wled_ui_imports += `
#include "ui/${ header_file }"`
		if (!['404'].includes(name)) viewled_server_routes.push(buildWLEDServerRoute(route, `PAGE_${name}`, lookup(ext)||'text/plain'))

		// Add to totals
		total_size += html.length
		total_compressed_size += gzip_buffer.length
	}

	//
	// Handle Static Assets

	const static_assets = await readdir(toAbsolute('../dist/static/assets'))
	for (const asset of static_assets) { // Loop through each asset file
		const { ext, name } = parse(asset) // Split extension and file name
		const asset_name = name.replace(/\./g, '_') // Replace all `.` in the asset name with `_` (eg `index.6d94cf91` -> `index_6d94cf91`)

		const content = await readFile(toAbsolute('../dist/static/assets', asset)) // Read the asset file's content
		const gzip_buffer = await gzip(content, { level: ZLIB.Z_BEST_COMPRESSION }) // Compress the asset file's content

		// Build a static header file for this asset
		const header_source = `/*
 * Binary array for VieWLED UI asset.
 * gzip is used for smaller size and improved speeds.
 */

// Autogenerated from ${ asset }, do not edit
const uint16_t ASSET_${asset_name}_L = ${ gzip_buffer.length };
const uint8_t ASSET_${asset_name}[] PROGMEM = {
${ toHexString(gzip_buffer) }
};`

		let header_file = `${ ext.replace('.', '') }_${ name }.h` // eg `index.6d94cf91.js` -> `js_index.6d94cf91.h`
		await writeFile(toAbsolute(`../dist/wled00/ui/assets/${ header_file }`), header_source) // Write the header file to the assets dir

		// Add a new line to the WLED router code for this asset
		wled_ui_imports += `
#include "ui/assets/${ header_file }"`
		viewled_server_routes.push(buildWLEDServerRoute(`/assets/${ asset }`, `ASSET_${asset_name}`, lookup(ext)||'text/plain'))

		// Add to totals
		total_size += content.length
		total_compressed_size += gzip_buffer.length
	}

	// Write an index file that imports all our static assets
	await writeFile(toAbsolute('../dist/wled00/web_ui.h'), wled_ui_imports)

	const viewled_server_data = `void initVieWLEDServer()
{
${ viewled_server_routes.join('\n') }
}`
	await writeFile(toAbsolute('../dist/wled00/viewled_server.cpp'), viewled_server_data)

	console.log(`Done!
Total size: ${ (total_size / 1024).toFixed(2) }KB
Total Compressed Size: ${ (total_compressed_size / 1024).toFixed(2) }KB`)
	process.exit()
}

init().catch(e => {
	console.error(e)
	process.exit(0)
})
